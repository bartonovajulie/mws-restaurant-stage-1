class DBHelper{static get DATABASE_URL(){const port=1337;return `http://localhost:${port}`}
    static get PROMISE_RESOLVED(){if(!navigator.serviceWorker){return Promise.resolve()}
        return idb.open('restaurants',1,function(upgradeDb){const store1=upgradeDb.createObjectStore("restaurants",{keyPath:'id'});const store2=upgradeDb.createObjectStore("reviews",{keyPath:'id',autoIncrement:!0});const store3=upgradeDb.createObjectStore("offline-reviews",{keyPath:'id',autoIncrement:!0})})}
    static fetchFavoriteRestaurant(id,checked){DBHelper.PROMISE_RESOLVED.then(db=>{if(!db)return;return db.transaction('restaurants').objectStore('restaurants').get(id)}).then(obj=>{let data=obj;data.is_favorite=checked;DBHelper.PROMISE_RESOLVED.then(db=>{db.transaction('restaurants','readwrite').objectStore('restaurants').put(data)})});fetch(`${DBHelper.DATABASE_URL}/restaurants/${id}`,{method:'PUT',headers:{"Content-Type":"application/json; charset=utf-8",},body:JSON.stringify({'is_favorite':checked})}).then((response)=>{response.json()}).catch(error=>console.error(`Fetch Error =\n`,error))}
    static fetchReviews(id,callback){id=parseInt(id);let badRestaurant=!0;DBHelper.PROMISE_RESOLVED.then(db=>{if(!db)return;const tx=db.transaction('reviews','readwrite');const store=tx.objectStore('reviews');return store.getAll()}).then(allReviews=>{allReviews.forEach(review=>{if(review.restaurant_id===id){badRestaurant=!1}});if(allReviews.length===0||badRestaurant===!0){console.log('empty idb db or idb doesnt contain reviews of this restaurant');fetch(`${DBHelper.DATABASE_URL}/reviews/?restaurant_id=${id}`).then((response)=>{console.log('get json from the server');return response.json()}).then((response)=>{console.log('save reviews into the idb db');const reviews=response;this.PROMISE_RESOLVED.then(db=>{const tx=db.transaction('reviews','readwrite');const store=tx.objectStore('reviews');reviews.forEach(review=>{store.put(review)})});callback(null,reviews)}).catch((error)=>{callback(error,null)})}else{console.log('from the idb db');callback(null,allReviews)}})}
    static creatNewReview(newReview){fetch(`${DBHelper.DATABASE_URL}/reviews`,{method:'POST',headers:{"Content-Type":"application/json; charset=utf-8",},body:JSON.stringify(newReview)}).then((response)=>{response.json().then(review=>{DBHelper.PROMISE_RESOLVED.then(db=>{if(!db)return;const tx=db.transaction('reviews','readwrite');const store=tx.objectStore('reviews');store.put(review)});return review})}).catch((error)=>{console.error(`Fetch Error =\n`,error);DBHelper.PROMISE_RESOLVED.then(db=>{if(!db)return;const tx=db.transaction('offline-reviews','readwrite');const store=tx.objectStore('offline-reviews');store.put(newReview);const tx2=db.transaction('reviews','readwrite');const store2=tx2.objectStore('reviews');store2.put(newReview)})})};static sendReviewsToServer(){console.log('Send reviews from offline-reviews IDB to server.');DBHelper.PROMISE_RESOLVED.then(db=>{if(!db)return;const tx=db.transaction('offline-reviews','readwrite');const store=tx.objectStore('offline-reviews');store.getAll().then(reviews=>{reviews.forEach(review=>{DBHelper.creatNewReview(review)});store.clear()})})}
    static fetchRestaurants(callback){DBHelper.PROMISE_RESOLVED.then(db=>{if(!db)return;const tx=db.transaction('restaurants','readwrite');const store=tx.objectStore('restaurants');return store.getAll()}).then(allRestaurants=>{if(allRestaurants.length===0){console.log('empty idb db');fetch(`${DBHelper.DATABASE_URL}/restaurants`).then((response)=>{console.log('get json from the server');return response.json()}).then((response)=>{console.log('save restaurants into the idb db');const restaurants=response;this.PROMISE_RESOLVED.then(db=>{const tx=db.transaction('restaurants','readwrite');const store=tx.objectStore('restaurants');restaurants.forEach(restaurant=>{store.put(restaurant)})});callback(null,restaurants)}).catch((error)=>{callback(error,null)})}else{console.log('from the idb db');callback(null,allRestaurants)}})}
    static fetchRestaurantById(id,callback){DBHelper.fetchRestaurants((error,restaurants)=>{if(error){callback(error,null)}else{const restaurant=restaurants.find(r=>r.id==id);if(restaurant){callback(null,restaurant)}else{callback('Restaurant does not exist',null)}}})}
    static fetchRestaurantByCuisine(cuisine,callback){DBHelper.fetchRestaurants((error,restaurants)=>{if(error){callback(error,null)}else{const results=restaurants.filter(r=>r.cuisine_type==cuisine);callback(null,results)}})}
    static fetchRestaurantByNeighborhood(neighborhood,callback){DBHelper.fetchRestaurants((error,restaurants)=>{if(error){callback(error,null)}else{const results=restaurants.filter(r=>r.neighborhood==neighborhood);callback(null,results)}})}
    static fetchRestaurantByCuisineAndNeighborhood(cuisine,neighborhood,callback){DBHelper.fetchRestaurants((error,restaurants)=>{if(error){callback(error,null)}else{let results=restaurants
        if(cuisine!='all'){results=results.filter(r=>r.cuisine_type==cuisine)}
        if(neighborhood!='all'){results=results.filter(r=>r.neighborhood==neighborhood)}
        callback(null,results)}})}
    static fetchNeighborhoods(callback){DBHelper.fetchRestaurants((error,restaurants)=>{if(error){callback(error,null)}else{const neighborhoods=restaurants.map((v,i)=>restaurants[i].neighborhood)
        const uniqueNeighborhoods=neighborhoods.filter((v,i)=>neighborhoods.indexOf(v)==i)
        callback(null,uniqueNeighborhoods)}})}
    static fetchCuisines(callback){DBHelper.fetchRestaurants((error,restaurants)=>{if(error){callback(error,null)}else{const cuisines=restaurants.map((v,i)=>restaurants[i].cuisine_type)
        const uniqueCuisines=cuisines.filter((v,i)=>cuisines.indexOf(v)==i)
        callback(null,uniqueCuisines)}})}
    static urlForRestaurant(restaurant){return(`./restaurant.html?id=${restaurant.id}`)}
    static imageUrlForRestaurant(restaurant){return(`/img/${restaurant.photograph}`)}
    static thumbUrlForRestaurant(restaurant){return(`/img/thumb/${restaurant.photograph}`)}
    static mapMarkerForRestaurant(restaurant,map){const marker=new L.marker([restaurant.latlng.lat,restaurant.latlng.lng],{title:restaurant.name,alt:restaurant.name,url:DBHelper.urlForRestaurant(restaurant)})
        marker.addTo(newMap);return marker}}